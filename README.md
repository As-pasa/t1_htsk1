Приложение представляет собой слой модели веб приложения. Затрагивает интеграцию с базой данных postgreSQL, orm-сущности, репозитории и соответствующие сервисы. 

### Сущности

Приложение использует сущности "User", '"Order". User обладает полями Id, name, email, orders. Последнее - список заказов, сделанных пользователем. Order обладает полями Id, product, user, state. State - определенное в приложении перечисление OrderState. 

Использование механизма перечислений выбрано в первую очередь с целью устранения ошибок основанных на опечатках при написании кода, связанного с заказами, а так же чтобы снять с программиста необходимость запоминать строковые литералы статусов.

Id в обоих сущностях генерируется автоматически по стратегии GenerationType.AUTO.

При работе с полями базы данных следует обратить внимание, что сущность User ассоциирована с таблицей users, сущность Order ассоциирована с таблицей orders. 

Между сущностями определена связь One-To-Many (User -> Order).

Помимо get/set методов, сущности предоставляют методы setState, принимающие экземпляр соответствующий сущности и устанавливающие значения полей сущности(кроме Id) на значения полей аргумента. Данные методы созданы для лучшего контроля за внутренним состоянием объектов сущностей.

### Сервисы
Приложение имеет 2 сервиса: UserService и OrderService. Каждый сервис предоставляет методы работы с базой данных, а именно сохранение, изменение, поиск и удаление.

Кроме них в сервисах определены фабричные методы Init..(*args*).
Для UserService этот метод создает пользователя с пустым списком заказов, для OrderService создает заказ со статусом New.

Для демонстрации работы AOP фабричные методы помечены кастомной аннотацией @IgnoreLogging. Благодаря ней в логи будут попадать только вызовы функций, непосредственно работающих с базой данных.


### логирование
логирование в приложении выполняется с помощью библиотеки Log4j2, смена механизма логирования возможна с помощью изменения функции в классе LoggingConfig. 

Для тестирования логирующей подсистемы, логер необходимо было заменить с помощью Mockito, именно этим обусловлено создание класса конфигурации, а не ручное разрешение зависимости.

Для отделения логики логирования от бизнесс логики используется фреймворк Spring-Boot-Starter-AOP. Для демонстрации работы АОП в приложении определено 2 реализации логирующего аспекта: LoggingAspectAround и LoggingAspectMultiple.

LoggingAspectAround работает на основе 1 совета Around, который логирует как успешный результат работы функции, так и вызов исключения.

LoggingAspectMultiple работает на основе советов Before, AfterReturning, AfterThrowing. 

Оба аспекта применяют логирование ко всем функциям в пакете \*.services, кроме тех, что помечены аннотацией @IgnoreLogging

По функциональности оба аспекта аналогичны. Первым был реализован аспект LoggingAspectAround, после LoggingAspectMultiple. После применения обоих подходов, отдаю предпочтение использованию LoggingAspectMultiple. Разделение разных веток логирования позволяет более гибко настраивать их в дальнейшем.

### Тестирование

Существующие тесты направлены исключительно на проверку работы логирующих аспектов. Тесты закрепляют следующее:
- Создается по крайне мере одна запись в логе при вызове функции, на которую указывает pointCut
- После успешного выполнения функции на которую указывает pointCut логируется результат выполнения функции
- После завершения выполнения функции с исключением происходит логирование исключения
- Запись лога содержит имя метода и аргументы метода
- При вызове метода помеченного аннотацией @IgnoreLogging не создается новых записей в логе

Этот набор тестов демонстрирует, работоспособность аспекта на одном из сервисов. Логика работы аспекта не зависит от логики работы сервиса, так что в приложении которое не будет реально использоваться можно обойтись тестированием на примере одного сервиса.

### Конфигурация
Для конфигурации приложения необходимо определить переменные окружения DB_URL, DB_USERNAME, DB_PASSWORD. Также на машине должен быть установлен postgresql сервер.

Конфигурация Аспектов
Выбор используемого аспекта выполняется через параметр конфигурационного файла application.properties aspect.enabled

Свойство может принимать значения multiple | around. При отсутствии строчки с заданным свойством приложение работает так, будто выбран вариант multiple

